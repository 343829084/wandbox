var compiler_config = #{decodedCompilerConfig};
function ArrayMap(field, init) {
  var self = this;
  self.keys = {};
  self.array = [];
  self.has_key = function(key) {
    return key in self.keys;
  };
  self.push = function(obj) {
    var key = obj[field];
    if (self.has_key(key))
      return;
    self.array.push(obj);
    self.keys[key] = obj;
  };

  (init || []).forEach(function(v) {
    self.push(v);
  });
};
var mapped_compiler_config = new ArrayMap('name', compiler_config);

function CompilerConfig(compiler_name) {
  var self = this;
  var as_array = function(obj) {
    if (typeof(obj) != "object" || obj.length === undefined) return [obj];
    else return obj;
  };

  var get_with_parents = function(compiler, key) {
    if (key in compiler)
      return compiler[key];
    var parents = as_array(compiler.inherits || []);
    for (var i = 0; i < parents.length; i++) {
      var cpr = mapped_compiler_config.keys[parents[i]];
      var result = get_with_parents(cpr, key)
      if (result !== undefined)
        return result;
    }
  };

  self.get = function(key) {
    var compiler = mapped_compiler_config.keys[compiler_name];
    return get_with_parents(compiler, key);
  };

  var Switch = function(obj) {
    this.get = function(key) {
      return key == 'flags' ? as_array(obj[key]) : obj[key];
    };
  };

  var get_switches_with_parents = function(compiler, results) {
    var parents = as_array(compiler.inherits || []);
    for (var i = 0; i < parents.length; i++) {
      var cpr = mapped_compiler_config.keys[parents[i]];
      get_switches_with_parents(cpr, results)
    }
    switches_ = compiler.switches || [];
    for (var i = 0; i < switches_.length; i++) {
      results.push(switches_[i]);
    }
  };

  self.get_switches = function() {
    var compiler = mapped_compiler_config.keys[compiler_name];
    var results = new ArrayMap('name');
    get_switches_with_parents(compiler, results);
    return results.array.map(function(v) { return new Switch(v); });
  };
}

var keybindings = {
    ace: null,
    vim: require("ace/keyboard/vim").handler,
    emacs: "ace/keyboard/emacs",
};

function decode_uri(str) {
  return decodeURIComponent(str);
}

function encode_html_entity(str) {
  return $.map(str, function(c) {
    if (c == ' ') return '&nbsp;';
    if (c == '<') return '&lt;';
    if (c == '>') return '&gt;';
    if (c == '&') return '&amp;';
    if (c == '"') return '&quot;';
    if (c == "'") return '&#39;';
    return c;
  }).join("");
}

function parse(str) {
  var index = str.indexOf(':');
  return {
    type: str.substring(0, index),
    message: str.substring(index + 1),
  };
}

function post_code() {
  var url = $('#compile').attr('href');
  var compiler = $('#compiler').val();
  var code = ace.edit('editor').getValue();
  var options = $("#compile_options").find(':checked').map(function(n,e) { return $(e).val(); });

  $.post('@{CompileR sourceId}', {
    compiler: compiler,
    code: code,
    options: options.get().join(',') }, function() { });

  // make permlink
  $('#permlink').remove();
  $('<a href="permlink" id="permlink" class="btn">Permlink</a>')
    .appendTo('#permdiv');
  $('#permlink').click(function(event) {
    event.preventDefault();
    post_permlink();
  });
}

function post_permlink() {
  var pm = $('#permlink');
  if (pm.hasClass('disable')) return;
  pm.addClass('disable');

  var url = $('#compile').attr('href');
  var compiler = $('#compiler').val();
  var code = ace.edit('editor').getValue();
  var options = $("#compile_options").find(':checked').map(function(n,e) { return $(e).val(); });

  $.post('@{PermlinkR}', {
    compiler: compiler,
    code: code,
    options: options.get().join(',') },
    function(json) {
      if (!json.success) {
        $('#permlink').removeClass('disable');
        return;
      }

      $('#permlink').remove();

      var approot = '@{RootR}'
      var url = approot + '/permlink/' + json.link;
      $('<a href="' + url + '" target="_blank" id="permlink">Permlink</a>')
        .appendTo('#permdiv');
    });
}

$(function() {
  absUrl = '@{SourceR sourceId}';
  src = new EventSource($.url(absUrl).attr('path'));
  src.onmessage = function(msg) {
    console.log(msg.data);
    data = parse(decode_uri(msg.data));
    $('<p>').html(encode_html_entity(data.message))
            .addClass(data.type)
            .appendTo('#output');
    $('#output')[0].scrollTop = $('#output')[0].scrollHeight;
  };

  $('#compile').click(function(event) {
    event.preventDefault();
    post_code();
  });
  $('#editor').keydown(function(event) {
    if (event.keyCode == 10 ||
        event.keyCode == 13 && event.ctrlKey) {
      event.preventDefault();
      post_code();
    }
  });

  var editor = ace.edit("editor");
  editor.setTheme("ace/theme/chrome");
  editor.getSession().setMode("ace/mode/c_cpp");
  $("#keybinding").change(function() {
        var value = $(this).val();
        editor.setKeyboardHandler(keybindings[value]);
  }).change();

  // initialize
  var compiler = decode_uri('#{urlEncode $ codeCompiler code}');
  var code = decode_uri('#{urlEncode $ codeCode code}');
  var check = function(elem, v) {
    v ? elem.attr('checked', '') : elem.removeAttr('checked');
  }
  $('#compiler').val(compiler);
  editor.setValue(code);
  //check($('#optimize'), optimize);
  //check($('#warning'), warning);

  $("#compiler").change(function() {
    $("#compile_options").empty();

    var compiler = new CompilerConfig($(this).val());
    var switches = compiler.get_switches();
    switches.forEach(function(v) {
      var checkbox = $('<div class="row-fluid"><input type="checkbox" value="' + v.get('name') + '"' + (v.get('default') ? 'checked' : '') + '>' + v.get('display-name') + '</input></div>');
      $("#compile_options").append(checkbox);
    });
  }).change();
});

